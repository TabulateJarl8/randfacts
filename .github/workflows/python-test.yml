on:
  workflow_call:
    inputs:
      python-versions:
        required: true
        type: string

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        python-version: ${{ fromJson(inputs.python-versions) }}

    container: ${{
      (contains(matrix.python-version, '3.6') || contains(matrix.python-version, '3.7'))
      && format('python:{0}-slim', matrix.python-version)
      || null
      }}

    steps:
      - uses: actions/checkout@v6

      - name: Install System Dependencies (Legacy Only)
        if: ${{ matrix.python-version == '3.6' || matrix.python-version == '3.7' }}
        run: |
          apt-get update
          apt-get install -y --no-install-recommends git curl gnupg2

      - name: Determine Poetry Version
        id: poetry
        run: |
          case "${{ matrix.python-version }}" in
            "3.6") echo "poetry_version=1.2.0a2" >> $GITHUB_OUTPUT ;;
            "3.7") echo "poetry_version=1.5.0" >> $GITHUB_OUTPUT ;;
            "3.8") echo "poetry_version=1.8.5" >> $GITHUB_OUTPUT ;;
            *) echo "poetry_version=2.2.1" >> $GITHUB_OUTPUT ;;
          esac

      # we should only setup-python if not in a container
      - name: Set up Python ${{ matrix.python-version }}
        if: ${{ !(matrix.python-version == '3.6' || matrix.python-version == '3.7') }}
        uses: actions/setup-python@v6
        with:
          python-version: ${{ matrix.python-version }}
          allow-prereleases: true

      # Cache the installation of Poetry itself, e.g. the next step. This prevents the workflow
      # from installing Poetry every time, which can be slow. Note the use of the Python version
      # number in the cache key
      - name: cache poetry install
        uses: actions/cache@v5
        with:
          path: ~/.local
          key: ${{ runner.os }}-poetry-${{ matrix.python-version }}

      # Install Poetry. You could do this manually, or there are several actions that do this.
      # `snok/install-poetry` seems to be minimal yet complete, and really just calls out to
      # Poetry's default install script, which feels correct. I pin the Poetry version here
      # because Poetry does occasionally change APIs between versions and I don't want my
      # actions to break if it does.
      #
      # The key configuration value here is `virtualenvs-in-project: true`: this creates the
      # venv as a `.venv` in your testing directory, which allows the next step to easily
      # cache it.
      - name: Install Poetry
        uses: snok/install-poetry@v1
        with:
          version: ${{ steps.poetry.outputs.poetry_version }}
          virtualenvs-create: true
          virtualenvs-in-project: true

      # Cache your dependencies (i.e. all the stuff in your `pyproject.toml`). Note the cache
      # key: if you're using multiple Python versions, or multiple OSes, you need to include
      # them in the cache key.
      - name: cache deps
        id: cache-deps
        uses: actions/cache@v5
        with:
          path: .venv
          key: pydeps-${{ runner.os }}-${{ matrix.python-version }}-${{ hashFiles('**/pyproject.toml', '**/poetry.lock') }}

      # Install dependencies. `--no-root` means "install all dependencies but not the project
      # itself", which is what you want to avoid caching _your_ code. The `if` statement
      # ensures this only runs on a cache miss.
      - name: Install dependencies
        if: steps.cache-deps.outputs.cache-hit != 'true'
        run: |
          if [ "${{ matrix.python-version }}" = "3.6" ]; then
            # 3.6 is incompatible with modern lockfiles
            rm -f poetry.lock
            poetry install --no-interaction --no-root
          else
            poetry install --no-interaction --no-root
          fi

      # Now install _your_ project. This isn't necessary for many types of projects -- particularly
      # things like Django apps don't need this. But it's a good idea since it fully-exercises the
      # pyproject.toml and makes that if you add things like console-scripts at some point that
      # they'll be installed and working.
      - run: poetry install --no-interaction

      - name: Static type checking
        run: poetry run mypy .

      # run the tests and check for 100% coverage
      - name: Run unit tests
        run: poetry run pytest . --cov=randfacts --cov-report=term-missing --cov-report=xml

      - name: Upload coverage reports to Codecov
        uses: codecov/codecov-action@v5.5.2
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          flags: python-${{ matrix.python-version }}
